1.2.8 值比较
- 所有比较运算符均返回布尔值
- 字符串比较，按字典序逐字进行比较
- 不同类型间的比较，当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小
- 严格相等
  - 普通的相等性检查 == 存在一个问题，它不能区分出 0 和 false，也同样无法区分空字符串和 false（不同类型比较，会被转换为number）
  - 严格相等运算符 === 在进行比较时不会做任何的类型转换，与“不相等”符号 != 类似，“严格不相等”表示为 !==
- 对 null 和 undefined 进行比较：
  - 当使用严格相等 === 比较二者时，结果为 false
  - 当使用非严格相等 == 比较二者时，结果为true
  - 当使用数学式或其他比较方法 < > <= >= 时，null/undefined 会被转化为数字：null 被转化为 0，undefined被转化为 NaN
- null vs 0:
  - 相等性检查 == 和普通比较符 > < >= <= 的代码逻辑是相互独立的
alert( null > 0 );  // (1) false 进行值比较时，null会被转化为数字0
alert( null == 0 ); // (2) false null只和undefined相等
alert( null >= 0 ); // (3) true
- 特立独行的 undefined，undefined不应该与其他值进行比较，进行值比较时会被转化为 NaN
- 避免问题
  - 除了严格相等 === 外，其他但凡是有 undefined/null 参与的比较，都需要格外小心
  - 除非你非常清楚自己在做什么，否则永远不要使用 >= > < <= 去比较一个可能为null/undefined 的变量。对于取值可能是 null/undefined 的变量，请按需要分别检查它的取值情况

1.2.9 条件分支：if 和 '?'
- 建议每次使用 if 语句都用大括号 {} 来包装代码块，即使只有一条语句
- '?' 支持三元运算符
- 多个 `?`，例如：
let age = prompt('age?', 18);

let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';

alert( message );
//注意代码的书写格式，增加可读性

1.2.10 逻辑运算符
- avaScript 中有四个逻辑运算符：||（或），&&（与），!（非），??（空值合并运算符）
- 或运算符
  - 一个或运算 || 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值
    - 获取变量列表或者表达式中的第一个真值
    - 短路求值（Short-circuit evaluation）
- 与运算符
  - 与运算寻求第一个假值，与运算返回第一个假值，如果没有假值就返回最后一个值
  - 与运算 && 的优先级比或运算 || 要高
- 非运算符
  - 将操作数转化为布尔类型：true/false
  - 返回相反的值
  - 两个非运算 !! 有时候用来将某个值转化为布尔类型
  - 非运算符 ! 的优先级在所有逻辑运算符里面最高

1.2.11 空值合并运算符 ??
- 当一个值既不是 null 也不是 undefined 时，我们将其称为“已定义的（defined）”
- a ?? b一种获得两者中的第一个“已定义的”值的不错的语法
- ?? 与 ||的区别：
  - || 返回第一个 真 值，不能区分 false、0、空字符串和null/underfined
  - ?? 返回第一个 已定义的 值
- ?? 运算符的优先级与 || 相同
- 出于安全原因，JavaScript 禁止将 ?? 运算符与 && 和 || 运算符一起使用，除非使用括号明确指定了优先级

1.2.11 循环：while 和 for
- 循环体的单次执行叫作 一次迭代
- for 循环的任何语句段都可以被省略
- for 的两个 ; 必须存在，否则会出现语法错误
- Continue 指令利于减少嵌套
- 注意：非表达式的语法结构不能与三元运算符 ? 一起使用，禁止 break/continue 在?的右边
- break/continue 标签
  - 用来解决问题，需要一次从多层嵌套的循环中跳出来
  - 标签 是在循环之前带有冒号的标识符，使用 continue/break + 标签 可以跳转到标签处，标签必须位于跳转代码之前

1.2.12 "switch" 语句
- switch 语句可以替代多个 if 判断
- switch 语句为多分支选择的情况提供了一个更具描述性的方式
- switch 语句有至少一个 case 代码块和一个可选的 default 代码块
- 如果没有 break，程序将不经过任何检查就会继续执行下一个 case
- 任何表达式都可以成为 switch/case 的参数
- 匹配时的相等时严格相等===，类型很关键

1.2.13 函数
- 函数声明，function 关键字首先出现，然后是 函数名，然后是括号之间的 参数 列表，最后是花括号之间的代码（即“函数体”）
- 如果在函数内部声明了同名变量，那么函数会 遮蔽 外部变量（就近原则）
- 参数的默认值：
  - 一个函数被调用，但有参数（argument）未被提供，那么相应的值就会变成 undefined
  - 可以使用 = 为函数声明中的参数指定所谓的“默认”（如果对应参数的值未被传递则使用）值
  - 示例：
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() 仅在没有给定 text 时执行
  // 其运行结果将成为 text 的值
}
- 可以通过参数与undefined严格相等，逻辑与，空值合并运算，来检查参数
- 返回值：
  - 只使用 return 但没有返回值也是可行的，但这会导致函数立即退出
  - 注意：空值的 return 或没有 return 的函数返回值为 undefined
  - return(长表达式)，不能将 return 和 长表达式 分开写成两行，因为 js 会默认给 return 后补上分号
- 函数命名：
  - 函数名应该清楚地描述函数的功能
  - 一个函数是一个行为，所以函数名通常是动词
  - 目前有许多优秀的函数名前缀，如 create…、show…、get…、check… 等等

1.2.14 函数表达式
- 函数表达式，示例：
let sayHi = function() {alert( "Hello" );}; //注意函数体末尾大括号的分号，因为函数表达式在赋值语句中
//functin后面没有函数名，函数表达式允许省略函数名
- 无论函数是如何创建的，函数都是一个值，可以复制函数到其他变量
- 回调函数：
  - 将函数作为参数传递，例如：
// 根据用户的回答，调用不同的函数
function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
}

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// 用法：函数 showOk 和 showCancel 被作为参数传入到 ask
ask("Do you agree?", showOk, showCancel);
- 一个函数是表示“行为”的值，可以在变量之间传递
- 严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见
- 函数声明在声明它的代码块内任意位置都可用
- 函数声明和函数表达式的区别：
  - 如果函数在主代码流中被声明为单独的语句，则称为“函数声明”
  - 如果该函数是作为表达式的一部分创建的，则称其“函数表达式”
  - 在执行代码块之前，内部算法会先处理函数声明。所以函数声明在其被声明的代码块内的任何位置都是可见的
  - 函数表达式在执行流程到达时创建

1.2.15 箭头函数，基础知识
- 单行箭头函数，从 => 的左侧获取参数，计算并返回右侧表达式的计算结果，(...args) => expression示例：
let sum = (a, b) => a + b;

/* 这个箭头函数是下面这个函数的更短的版本：
let sum = function(a, b) {
  return a + b;
};*/
alert( sum(1, 2) ); // 3
- 多行的箭头函数，需要显示添加 return , (...args) => { body }示例：
let sum = (a, b) => {  // 花括号表示开始一个多行函数
  let result = a + b;
  return result; // 如果我们使用了花括号，那么我们需要一个显式的 “return”
};

alert( sum(1, 2) ); // 3